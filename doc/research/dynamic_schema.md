### Background
Right now, when the repository or configuration are modified, the schema must be regenerated by running a command, and the container recompiled. The proof-of-concept belows works around that by hooking into several parts of the schema's building process.

The schema that has been generated on disk is still used to compile the cache, create the services, etc. But after the schema is loaded, it is modified based on changes that happened on the system. Content types can be added or modified.

### Bits and pieces
Most of the code for this is in the `Schema\DynamicSchema` namespace.

#### `HotGraphQLTypesCommand`
One of the temporary entry-points. It simulates what must be done when a change that affects the GraphQL schema occurs, in that case a new content type was added. What it does would be part of some event sub-system attached to the dispatcher.

The script takes a content type identifier as the input, and generates the schema from it as if the console command had been executed. The goal is to:
- create the matching PHP class in `var/cache/{env}/overblog/__DEFINITIONS__/`
- store somewhere that the type was added, as well as the changes to existing types

#### `PreExecutorSubscriber`
Adds hot-loaded types to the types registry (see the command)

#### `DynamicSchema\ConfigProcessor`
Service tagged as `overblog_graphql.type_resolver`. Can process the schema config after it has been read from the configuration and before it gets used.

It shows how a field that loads a content type can be added to the content type group's fields.

#### `SchemaDiffBuilder`
An extended GraphQL schema builder, that:
- accepts additions of fields to unknown types
- logs what types have been added, and what types have been modified

Right now it is used by the script.
